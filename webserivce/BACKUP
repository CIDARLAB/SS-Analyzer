from flask import Flask, jsonify, abort, make_response, request
import networkx as nx
import json
import numpy as np
import Channel_Resistance
import Mixer_Resistance

#JSON Parser is designed to form primitive graph connections and then save corresponding data

#RESTful API stuff 
app = Flask(__name__)

tasks = [
    {
        'id': 1,
        'title': u'Buy groceries',
        'description': u'Milk, Cheese, Pizza, Fruit, Tylenol', 
        'done': False
    },
    {
        'id': 2,
        'title': u'Learn Python',
        'description': u'Need to find a good Python tutorial on the web', 
        'done': False
    }
]

@app.route('/todo/api/v1.0/tasks', methods=['GET'])
def get_tasks():
    return jsonify({'tasks': tasks})

@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['GET'])
def get_task(task_id):
    task = [task for task in tasks if task['id'] == task_id]
    if len(task) == 0:
        abort(404)
    return jsonify({'task': task[0]})

@app.route('/todo/api/v1.0/tasks', methods=['POST'])
def create_task():
    
    if not request.json:
        abort(400)

    parsed_JSON = request.get_json()
    #comps = parsed_JSON.get("components")

    return jsonify(parsed_JSON),201

@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    task = [task for task in tasks if task['id'] == task_id]
    if len(task) == 0:
        abort(404)
    if not request.json:
        abort(400)
    if 'title' in request.json and type(request.json['title']) != unicode:
        abort(400)
    if 'description' in request.json and type(request.json['description']) is not unicode:
        abort(400)
    if 'done' in request.json and type(request.json['done']) is not bool:
        abort(400)
    task[0]['title'] = request.json.get('title', task[0]['title'])
    task[0]['description'] = request.json.get('description', task[0]['description'])
    task[0]['done'] = request.json.get('done', task[0]['done'])
    return jsonify({'task': task[0]})

@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    task = [task for task in tasks if task['id'] == task_id]
    if len(task) == 0:
        abort(404)
    tasks.remove(task[0])
    return jsonify({'result': True})

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)

if __name__ == '__main__':
    app.run(debug=True)


#**********************************************************************************************************

#Implementation of back end code 
class Device:

    def __init__(self,component,connection):
        self.component = component
        self.connection = connection

class Component:

    def __init__(self,name,layers,ID,params,ports,entity):
        self.name = name
        self.layers = layers
        self.id = ID
        self.params = params
        self.ports = ports
        self.entity = entity

    def __str__(self):
        return str(self.__dict__)

    def __repr__(self):
        return str(self.__dict__)

class Connection:

    def __init__(self,sinks,name,ID,source,params,layer):
        self.sinks = sinks
        self.name = name
        self.id = ID
        self.source = source
        self.params = params
        self.layer = layer 

    def __str__(self):
        return str(self.__dict__)
    
    def __repr__(self):
        return str(self.__dict__)

class Port:

    def __init__(self,x,y,label,layer):
        self.x = x
        self.y = y
        self.label = label
        self.layer = layer

    def __str__(self):
        return str(self.__dict__)
    
    def __repr__(self):
        return str(self.__dict__)


class Target:

    def __init__(self,component,port):
        self.component = component
        self.port = port

    def __str__(self):
        return str(self.__dict__)

#Initialize Variables
#parsed_JSON = json.load(open('JSON_Tests/test.json'))
print("hi")
G = nx.MultiGraph()
components = []
connections = []
targets = []
resistance_data = {}
temp_port = 0
primitive_res = 0

#Iterate through components and save as Component Objects
for component in parsed_JSON["components"]:
    name = component["name"]
    layers = component["layers"]
    ID = component["id"]
    params = component["params"]
    ports = component["ports"]
    entity = component["entity"]
    num_ports = len(component["ports"])
    
    #Reset list of Port Objects 
    ports_to_add = []

    #For each component save port data as Port Object
    
    if(num_ports != 0):
        for port in component["ports"]:
            x = port["x"]
            y = port["y"]
            label = port["label"]
            layer = port["layer"]
            
            #Append list of Port Objects
            ports_to_add.append(Port(x,y,label,layer))
            #Append list of Target Objects 
            targets.append(Target(ID,Port(x,y,label,layer)))
    

    #Append list of Component Objects using list of Port Objects 
    components.append(Component(name,layers,ID,params,ports_to_add,entity))

#Iterate through connections and save as Component Objects 
for connection in parsed_JSON["connections"]:
    sinks = connection["sinks"]
    name = connection["name"]
    ID = connection["id"]
    source = connection["source"]
    params = connection["params"]
    layer = connection["layer"]

    #Append list of Connection Objects 
    connections.append(Connection(sinks,name,ID,source,params,layer))

#Calculate all primitive resistances in JSON
for component in parsed_JSON["components"]:

    if(component["entity"] == "MIXER"):
        bendSpacing = component["params"]["bendSpacing"]
        numberOfBends = component["params"]["numBends"]
        channelWidth = component["params"]["channelWidth"]
        bendLength = component["params"]["bendLength"]

        primitive_res = Mixer_Resistance.Mixer_R(bendSpacing,numberOfBends,channelWidth,bendLength)

        resistance_data[component["id"]] = primitive_res
    
    if(component["entity"] == "PORT"):

        primitive_res = 100
        resistance_data[component["id"]] = primitive_res

    #Calculate each channel connected to the primitive 
    for connection in parsed_JSON["connections"]:
        width = connection["params"]["width"]
        depth = connection["params"]["depth"]
        primitive_res = Channel_Resistance.Channel_R(width,depth)
        resistance_data[connection["id"]] = primitive_res


#For each component connect to channel and vice versa and include resistance values in graph 
for component in parsed_JSON["components"]:
    for connection in parsed_JSON["connections"]:
          
        if(component["id"] == connection["source"]["component"]):
            res = resistance_data[connection["name"]]
            G.add_edge(component["id"],connection["name"], pressure = 0, flow = 2)
        
        if(component["id"] == connection["sinks"][0]["component"]):
            res = resistance_data[component["id"]]
            G.add_edge(connection["name"],component["id"], pressure = 0, flow = 2)


#Print Statements 
print("EDGES: ")
print(G.edges.data())
print("\n")

print("********* COMPONENTS *********")
print("\n")
for component in components:
    print(component)
    print("\n")

print("********* CONNECTIONS *********")
print("\n")
for connection in connections:
    print(connection)
    print("\n")

print("********* TARGETS *********")
print("\n")
for target in targets:
    print(target)
    print("\n")

print("********* RESISTANCE DICTIONARY *********")
print(resistance_data)
print("\n")
'''
for i in range(0,len(ports)):
    print(ports[i])
'''

'''
print("********* PATH BETWEEN START AND END *********")
for path in nx.all_simple_paths(G, source = "port_in1", target = "port_out"):
    print(path)
    print("\n")
'''